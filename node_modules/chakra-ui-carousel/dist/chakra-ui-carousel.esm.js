import { Flex, Box, VStack, useTheme, useMediaQuery, Button } from '@chakra-ui/react';
import React, { createContext, useState, useCallback, useMemo, useContext, useLayoutEffect, useRef, useEffect } from 'react';
import { useBoundingclientrectRef } from 'rooks';
import { motion, useAnimation, useMotionValue } from 'framer-motion';
import { ChevronLeftIcon, ChevronRightIcon } from '@chakra-ui/icons';

const Context = /*#__PURE__*/createContext(undefined);
const Provider = ({
  children
}) => {
  const [trackIsActive, setTrackIsActive] = useState(false);
  const [multiplier, setMultiplier] = useState(0.35);
  const [sliderWidth, setSliderWidth] = useState(0);
  const [activeItem, setActiveItem] = useState(0);
  const [constraint, setConstraint] = useState(0);
  const [itemWidth, setItemWidth] = useState(0);
  const [positions, setPositions] = useState([]);
  const initSliderWidth = useCallback(width => setSliderWidth(width), []);
  const value = useMemo(() => ({
    trackIsActive,
    setTrackIsActive,
    multiplier,
    sliderWidth,
    activeItem,
    setActiveItem,
    constraint,
    initSliderWidth,
    itemWidth,
    setMultiplier,
    setItemWidth,
    setConstraint,
    positions,
    setPositions
  }), [trackIsActive, setTrackIsActive, multiplier, sliderWidth, activeItem, setActiveItem, constraint, initSliderWidth, itemWidth, setMultiplier, setItemWidth, setConstraint, positions, setPositions]);
  return /*#__PURE__*/React.createElement(Context.Provider, {
    value: value
  }, children);
};

const Item = ({
  index,
  gap,
  children
}) => {
  const context = useContext(Context);
  const {
    positions
  } = context;
  const [didUserTab, setDidUserTab] = useState(false);
  const handleFocus = () => context?.setTrackIsActive(true);
  const handleBlur = () => {
    didUserTab && index + 1 === positions.length && context?.setTrackIsActive(false);
    setDidUserTab(false);
  };
  const handleKeyUp = event => {
    if (!context) return;
    const {
      activeItem,
      constraint
    } = context;
    return event.key === "Tab" && !(activeItem === positions?.length - constraint) && context?.setActiveItem(index);
  };
  const handleKeyDown = event => event.key === "Tab" && setDidUserTab(true);
  return /*#__PURE__*/React.createElement(Flex, {
    onFocus: handleFocus,
    onBlur: handleBlur,
    onKeyUp: handleKeyUp,
    onKeyDown: handleKeyDown,
    w: `${context?.itemWidth}px`,
    _notLast: {
      mr: `${gap}px`
    },
    py: "4px"
  }, children);
};

const Slider = ({
  children,
  gap
}) => {
  const context = useContext(Context);
  const {
    initSliderWidth
  } = context;
  const [myRef, boundingClientRect] = useBoundingclientrectRef();
  useLayoutEffect(() => initSliderWidth(Math.round(boundingClientRect?.width ?? 0)), [boundingClientRect?.width, initSliderWidth]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Box, {
    ref: myRef,
    w: {
      base: "100%",
      md: `calc(100% + ${gap}px)`
    },
    ml: {
      base: 0,
      md: `-${gap / 2}px`
    },
    px: `${gap / 2}px`,
    position: "relative",
    overflow: "hidden",
    _before: {
      bgGradient: "linear(to-r, base.d400, transparent)",
      position: "absolute",
      w: `${gap / 2}px`,
      content: "''",
      zIndex: 1,
      h: "100%",
      left: 0,
      top: 0
    },
    _after: {
      bgGradient: "linear(to-l, base.d400, transparent)",
      position: "absolute",
      w: `${gap / 2}px`,
      content: "''",
      zIndex: 1,
      h: "100%",
      right: 0,
      top: 0
    }
  }, children));
};

/* eslint-disable @typescript-eslint/ban-ts-comment */
const MotionFlex = motion(Flex);
const Track = ({
  children
}) => {
  const context = useContext(Context);
  const {
    setTrackIsActive,
    trackIsActive,
    setActiveItem,
    activeItem,
    constraint,
    multiplier,
    itemWidth,
    positions
  } = context;
  const [dragStartPosition, setDragStartPosition] = useState(0);
  const controls = useAnimation();
  const x = useMotionValue(0);
  const node = useRef(null);
  const transitionProps = useMemo(() => ({
    stiffness: 400,
    type: "spring",
    damping: 60,
    mass: 3
  }), []);
  const handleDragStart = () => setDragStartPosition(positions[activeItem]);
  const handleDragEnd = (_, info) => {
    console.log(info);
    const distance = info.offset.x;
    const velocity = info.velocity.x * multiplier;
    const direction = velocity < 0 || distance < 0 ? 1 : -1;
    const extrapolatedPosition = dragStartPosition + (direction === 1 ? Math.min(velocity, distance) : Math.max(velocity, distance));
    const closestPosition = positions.reduce((prev, curr) => {
      return Math.abs(curr - extrapolatedPosition) < Math.abs(prev - extrapolatedPosition) ? curr : prev;
    }, 0);
    if (!(closestPosition < positions[positions.length - constraint])) {
      setActiveItem(positions.indexOf(closestPosition));
      controls.start({
        x: closestPosition,
        transition: {
          velocity: info.velocity.x,
          ...transitionProps
        }
      });
    } else {
      setActiveItem(positions.length - constraint);
      controls.start({
        x: positions[positions.length - constraint],
        transition: {
          velocity: info.velocity.x,
          ...transitionProps
        }
      });
    }
  };
  const handleResize = useCallback(() => controls.start({
    x: positions[activeItem],
    transition: {
      ...transitionProps
    }
  }), [activeItem, controls, positions, transitionProps]);
  const handleClick = useCallback(event =>
  // @ts-expect-error
  node?.current?.contains(event.target) ? setTrackIsActive(true) : setTrackIsActive(false), [setTrackIsActive]);
  const handleKeyDown = useCallback(event => {
    if (trackIsActive) {
      if (activeItem < positions.length - constraint) {
        if (event.key === "ArrowRight" || event.key === "ArrowUp") {
          event.preventDefault();
          // @ts-expect-error
          setActiveItem(prev => {
            return prev + 1;
          });
        }
      }
      if (activeItem > positions.length - positions.length) {
        if (event.key === "ArrowLeft" || event.key === "ArrowDown") {
          event.preventDefault();
          // @ts-expect-error
          setActiveItem(prev => {
            return prev - 1;
          });
        }
      }
    }
  }, [trackIsActive, setActiveItem, activeItem, constraint, positions.length]);
  useEffect(() => {
    handleResize();
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("mousedown", handleClick);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("mousedown", handleClick);
    };
  }, [handleClick, handleResize, handleKeyDown, positions]);
  useEffect(() => {
    console.log("activeItem", activeItem);
  }, [activeItem]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, itemWidth && /*#__PURE__*/React.createElement(VStack, {
    overflowX: "hidden",
    ref: node,
    spacing: 5,
    alignItems: "stretch"
  }, /*#__PURE__*/React.createElement(MotionFlex, {
    dragConstraints: node,
    onDragStart: handleDragStart,
    onDragEnd: handleDragEnd,
    animate: controls,
    style: {
      x
    },
    drag: "x",
    _active: {
      cursor: "grabbing"
    },
    minWidth: "min-content",
    flexWrap: "nowrap",
    cursor: "grab"
  }, children)));
};

const Carousel = ({
  children,
  gap
}) => {
  const context = useContext(Context);
  const {
    setItemWidth,
    sliderWidth,
    setMultiplier,
    setConstraint,
    itemWidth,
    setPositions
  } = context;
  const {
    breakpoints
  } = useTheme();
  useEffect(() => {
    const newPositions = children?.map((_, index) => -Math.abs((itemWidth + gap) * index));
    setPositions(newPositions);
  }, [children, gap, itemWidth, setPositions]);
  const [isBetweenBaseAndMd] = useMediaQuery(`(min-width: ${breakpoints?.base}) and (max-width: ${breakpoints?.md})`);
  const [isBetweenMdAndXl] = useMediaQuery(`(min-width: ${breakpoints?.md}) and (max-width: ${breakpoints?.xl})`);
  const [isGreaterThanXL] = useMediaQuery(`(min-width: ${breakpoints?.xl})`);
  useEffect(() => {
    if (isBetweenBaseAndMd) {
      setItemWidth(sliderWidth - gap);
      setMultiplier(0.65);
      setConstraint(1);
    }
    if (isBetweenMdAndXl) {
      setItemWidth(sliderWidth / 2 - gap);
      setMultiplier(0.5);
      setConstraint(2);
    }
    if (isGreaterThanXL) {
      setItemWidth(sliderWidth / 3 - gap);
      setMultiplier(0.35);
      setConstraint(3);
    }
  }, [isBetweenBaseAndMd, isBetweenMdAndXl, isGreaterThanXL, sliderWidth, gap, setItemWidth, setMultiplier, setConstraint]);
  return /*#__PURE__*/React.createElement(Slider, {
    gap: gap
  }, /*#__PURE__*/React.createElement(Track, null, children.map((child, index) => /*#__PURE__*/React.createElement(Item, {
    gap: gap,
    key: index,
    index: index
  }, child))));
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

const LeftButton = ({
  customIcon,
  ...props
}) => {
  const context = useContext(Context);
  const {
    setTrackIsActive,
    activeItem,
    positions,
    setActiveItem
  } = context;
  const handleFocus = () => setTrackIsActive(true);
  const handleDecrementClick = () => {
    setTrackIsActive(true);
    !(activeItem === positions.length - positions.length) &&
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    setActiveItem(prev => prev - 1);
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Button, _extends({}, props, {
    onClick: handleDecrementClick,
    onFocus: handleFocus,
    zIndex: 2,
    minW: 0
  }), customIcon ? /*#__PURE__*/React.createElement(Box, null, customIcon) : /*#__PURE__*/React.createElement(ChevronLeftIcon, {
    boxSize: 9
  })));
};

const RightButton = ({
  customIcon,
  ...props
}) => {
  const context = useContext(Context);
  const {
    setTrackIsActive,
    activeItem,
    constraint,
    positions,
    setActiveItem
  } = context;
  const handleFocus = () => setTrackIsActive(true);
  const handleIncrementClick = () => {
    setTrackIsActive(true);
    !(activeItem === positions.length - constraint) &&
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    setActiveItem(prev => prev + 1);
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Button, _extends({}, props, {
    onClick: handleIncrementClick,
    onFocus: handleFocus,
    zIndex: 2,
    minW: 0
  }), customIcon ? /*#__PURE__*/React.createElement(Box, null, customIcon) : /*#__PURE__*/React.createElement(ChevronRightIcon, {
    boxSize: 9
  })));
};

export { Carousel, Context, LeftButton, Provider, RightButton };
